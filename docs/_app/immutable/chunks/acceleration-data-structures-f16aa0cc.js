import{S as Bt,i as Mt,s as xt,D as Ye,x as Vt,y as At,z as Gt,A as Dt,B as Pt,f as Wt,t as Ft,C as $t,Q as St,l as s,u as l,a as c,m as i,p as r,v as h,h as t,c as u,F as It,q as N,b as o,G as n,n as zt}from"./index-2fdc1048.js";import{B as Ut}from"./_blog_layout-34b26a2e.js";const Ht="/_app/immutable/assets/bvh-median-322652fd.svg",Qt=Object.freeze(Object.defineProperty({__proto__:null,default:Ht},Symbol.toStringTag,{value:"Module"})),Ot="/_app/immutable/assets/bvh-midpoint-6ce7fca5.svg",Jt=Object.freeze(Object.defineProperty({__proto__:null,default:Ot},Symbol.toStringTag,{value:"Module"}));function Rt(j){let p,f,b,v,m,d,w,ye,K,T,je,X,E,Te,Z,k,Ee,ee,P,ke,te,S,Pe,ae,I,Se,oe,H,Ie,se,O,He,ie,B,Oe,ne,g,Be,Y,Me,re,M,Q,xe,le,x,Ve,he,V,A,Je,ce,G,J,Ae,ue,D,Ge,pe,W,F,Ke,me,$,De,de,z,We,fe,U,Fe,be,R,$e,ve,q,ze,we,C,Ue,ge,L,Re,_e,_,qe,y,Ce;return{c(){p=s("p"),f=l(`When rendering triangle meshes, calculating phaser hits, or finding out if the character falls on the ground,
we have to shoot many different rays and see if they hit anything. We can easily react thousands of rays to
render a single frame of our real-time application. To get acceptable frame-rates, we have to make raycasting
rather efficient.`),b=c(),v=s("p"),m=l(`Here, algorithms and data structures come to our rescue. We form data structures called the acceleration data
structures for the current state of the frame, and use this for the rendering or other raycasting operations.
These structures are usually specialised tree data structures, and we run binary search over them. They bring
the closest-object operation from linear time to logarithmic time.`),d=c(),w=s("h1"),ye=l("Bounding Volume Hierarchy"),K=c(),T=s("p"),je=l(`A bounding volume hierarchy (BVH) is a tree data structure where each leaf node contains a scene object or a set of
objects that we want to handle together. Other than that, each node contains a bounding volume description.
These can be cuboids, spheres etc. something that is easy to find ray intersections with.`),X=c(),E=s("h2"),Te=l("Generation"),Z=c(),k=s("p"),Ee=l(`The recursion happens until we reach the desired number of objects inside a leaf or we reach a certain number
of levels. Each step sorts the objects according to their coordinates, splits the sorted list into two, assigns
their bounding volumes, and keeps building each subtree. During the split, if we split at a given object, the
object goes to the lower partition. This is because we usually use integer division which will produce more even
partitions if we add the middle item to the lower partition instead of the upper. 0-based indices are assumed.`),ee=c(),P=s("p"),ke=l(`The bounding volume assignment has to make sure that all objects within the partition are enclosed completely
by the volume. It is better to optimise to have minimally sized volumes, but we don\u2019t have to; it could be hard
to do with spherical bounding volumes, for example.`),te=c(),S=s("h2"),Pe=l("Traversal"),ae=c(),I=s("p"),Se=l(`Each step intersects the ray with the both bounding volumes under the current node, then keeps traversing the
closer volume. If no hit happens, it has to traverse the farther volume also. When we reach the leaves we
try to intersect with each object in the leaf; if no hit happens we return a null distance to report no hit.`),oe=c(),H=s("p"),Ie=l(`If a hit happens within the closer volume, the step also traverses the farther volume if its bounding volume
distance is closer than the reported intersection distance of the closer node. This happens a lot if our chosen
splitting method (read below) have produced a hierarchy with a lot of intersecting bounding volumes.`),se=c(),O=s("h2"),He=l("Splitting Methods"),ie=c(),B=s("p"),Oe=l(`The best node splitting method depends on how the scene is laid out. The key thing we want to achieve is the
bounding volumes being spread as apart as possible at each level, so we have as much no-hit space as possible
when raycasting, allowing us to stop traversing at upper levels in this case. One method can in general be
better than the other but you can choose whichever is more performant in your specific application.`),ne=c(),g=s("p"),Be=l(`For the demonstrations, the first level of the bounding volumes is shown on the left hand side and the second
level of the bounding volumes on the right-hand-side. `),Y=s("em"),Me=l(`There would also be the root bounding volume which would
enclose all objects but is omitted.`),re=c(),M=s("p"),Q=s("strong"),xe=l("Median Object"),le=c(),x=s("p"),Ve=l(`If we split at the median triangle, we will get the most balanced tree. The tree height will be log(n) where n
is the number of objects.`),he=c(),V=s("p"),A=s("img"),ce=c(),G=s("p"),J=s("strong"),Ae=l("Midpoint"),ue=c(),D=s("p"),Ge=l(`If we split at the geometric midpoint, we get a tree where regions with more triangles get themselves a taller
subtree. This will make situations where one object covers a lot of triangles from the ray\u2019s point of view
much faster to compute intersection for.`),pe=c(),W=s("p"),F=s("img"),me=c(),$=s("p"),De=l(`As seen here, a midpoint split can yield unbalanced but much more spread-apart bounding volumes. If the rays
just pass in between the topmost bounding volumes we don\u2019t need to waste as much computation time in this case.`),de=c(),z=s("h2"),We=l("Optimisation"),fe=c(),U=s("p"),Fe=l("First, the BVH can be reused for any raycasting as long as any object doesn\u2019t change in between."),be=c(),R=s("p"),$e=l(`The generation can be implemented similarly to an in-place merge sort, so we should use data structures that
will make it indeed in-place. For traversal there isn\u2019t much to do.`),ve=c(),q=s("p"),ze=l(`One thing to note is that the splitting method I have described above creates nodes that are allocated in a
depth-first manner. You can also allocate the nodes then traverse to get pairs of bounding volumes next to each
other in memory. This is assuming you are allocating memory from athe lower to a higher address, e. g. by
appending to a list.`),we=c(),C=s("h1"),Ue=l("Objects outside of the Acceleration Data Structure"),ge=c(),L=s("p"),Re=l(`We always have the method of linear iteration in our hands, so we can use this whenever an object we want to
intersect is not in the acceleration data structure. If we have moving characters in a scene for an FPS game,
for example, we can first render the scene, also store its depth buffer, then blit the character renders onto
the background according to the background and character depth buffers. If we really need to test ray
intersection on the backgrounds and the character, we treat the background BVH as a single object, intersect
both the character and the background, and report the closest hit result among these tests.`),_e=c(),_=s("p"),qe=l(`Rigged meshes are very hard to generate acceleration data structures for. If the deformation happens before the
data is sent to the GPU, then the BVH can be generated each frame, including the character mesh triangles. This
seems like `),y=s("a"),Ce=l("how Epic Games\u2019 Unreal Engine Version 5 seems to work."),this.h()},l(e){p=i(e,"P",{});var a=r(p);f=h(a,`When rendering triangle meshes, calculating phaser hits, or finding out if the character falls on the ground,
we have to shoot many different rays and see if they hit anything. We can easily react thousands of rays to
render a single frame of our real-time application. To get acceptable frame-rates, we have to make raycasting
rather efficient.`),a.forEach(t),b=u(e),v=i(e,"P",{});var Xe=r(v);m=h(Xe,`Here, algorithms and data structures come to our rescue. We form data structures called the acceleration data
structures for the current state of the frame, and use this for the rendering or other raycasting operations.
These structures are usually specialised tree data structures, and we run binary search over them. They bring
the closest-object operation from linear time to logarithmic time.`),Xe.forEach(t),d=u(e),w=i(e,"H1",{});var Ze=r(w);ye=h(Ze,"Bounding Volume Hierarchy"),Ze.forEach(t),K=u(e),T=i(e,"P",{});var et=r(T);je=h(et,`A bounding volume hierarchy (BVH) is a tree data structure where each leaf node contains a scene object or a set of
objects that we want to handle together. Other than that, each node contains a bounding volume description.
These can be cuboids, spheres etc. something that is easy to find ray intersections with.`),et.forEach(t),X=u(e),E=i(e,"H2",{});var tt=r(E);Te=h(tt,"Generation"),tt.forEach(t),Z=u(e),k=i(e,"P",{});var at=r(k);Ee=h(at,`The recursion happens until we reach the desired number of objects inside a leaf or we reach a certain number
of levels. Each step sorts the objects according to their coordinates, splits the sorted list into two, assigns
their bounding volumes, and keeps building each subtree. During the split, if we split at a given object, the
object goes to the lower partition. This is because we usually use integer division which will produce more even
partitions if we add the middle item to the lower partition instead of the upper. 0-based indices are assumed.`),at.forEach(t),ee=u(e),P=i(e,"P",{});var ot=r(P);ke=h(ot,`The bounding volume assignment has to make sure that all objects within the partition are enclosed completely
by the volume. It is better to optimise to have minimally sized volumes, but we don\u2019t have to; it could be hard
to do with spherical bounding volumes, for example.`),ot.forEach(t),te=u(e),S=i(e,"H2",{});var st=r(S);Pe=h(st,"Traversal"),st.forEach(t),ae=u(e),I=i(e,"P",{});var it=r(I);Se=h(it,`Each step intersects the ray with the both bounding volumes under the current node, then keeps traversing the
closer volume. If no hit happens, it has to traverse the farther volume also. When we reach the leaves we
try to intersect with each object in the leaf; if no hit happens we return a null distance to report no hit.`),it.forEach(t),oe=u(e),H=i(e,"P",{});var nt=r(H);Ie=h(nt,`If a hit happens within the closer volume, the step also traverses the farther volume if its bounding volume
distance is closer than the reported intersection distance of the closer node. This happens a lot if our chosen
splitting method (read below) have produced a hierarchy with a lot of intersecting bounding volumes.`),nt.forEach(t),se=u(e),O=i(e,"H2",{});var rt=r(O);He=h(rt,"Splitting Methods"),rt.forEach(t),ie=u(e),B=i(e,"P",{});var lt=r(B);Oe=h(lt,`The best node splitting method depends on how the scene is laid out. The key thing we want to achieve is the
bounding volumes being spread as apart as possible at each level, so we have as much no-hit space as possible
when raycasting, allowing us to stop traversing at upper levels in this case. One method can in general be
better than the other but you can choose whichever is more performant in your specific application.`),lt.forEach(t),ne=u(e),g=i(e,"P",{});var Le=r(g);Be=h(Le,`For the demonstrations, the first level of the bounding volumes is shown on the left hand side and the second
level of the bounding volumes on the right-hand-side. `),Y=i(Le,"EM",{});var ht=r(Y);Me=h(ht,`There would also be the root bounding volume which would
enclose all objects but is omitted.`),ht.forEach(t),Le.forEach(t),re=u(e),M=i(e,"P",{});var ct=r(M);Q=i(ct,"STRONG",{});var ut=r(Q);xe=h(ut,"Median Object"),ut.forEach(t),ct.forEach(t),le=u(e),x=i(e,"P",{});var pt=r(x);Ve=h(pt,`If we split at the median triangle, we will get the most balanced tree. The tree height will be log(n) where n
is the number of objects.`),pt.forEach(t),he=u(e),V=i(e,"P",{});var mt=r(V);A=i(mt,"IMG",{src:!0,alt:!0}),mt.forEach(t),ce=u(e),G=i(e,"P",{});var dt=r(G);J=i(dt,"STRONG",{});var ft=r(J);Ae=h(ft,"Midpoint"),ft.forEach(t),dt.forEach(t),ue=u(e),D=i(e,"P",{});var bt=r(D);Ge=h(bt,`If we split at the geometric midpoint, we get a tree where regions with more triangles get themselves a taller
subtree. This will make situations where one object covers a lot of triangles from the ray\u2019s point of view
much faster to compute intersection for.`),bt.forEach(t),pe=u(e),W=i(e,"P",{});var vt=r(W);F=i(vt,"IMG",{src:!0,alt:!0}),vt.forEach(t),me=u(e),$=i(e,"P",{});var wt=r($);De=h(wt,`As seen here, a midpoint split can yield unbalanced but much more spread-apart bounding volumes. If the rays
just pass in between the topmost bounding volumes we don\u2019t need to waste as much computation time in this case.`),wt.forEach(t),de=u(e),z=i(e,"H2",{});var gt=r(z);We=h(gt,"Optimisation"),gt.forEach(t),fe=u(e),U=i(e,"P",{});var _t=r(U);Fe=h(_t,"First, the BVH can be reused for any raycasting as long as any object doesn\u2019t change in between."),_t.forEach(t),be=u(e),R=i(e,"P",{});var yt=r(R);$e=h(yt,`The generation can be implemented similarly to an in-place merge sort, so we should use data structures that
will make it indeed in-place. For traversal there isn\u2019t much to do.`),yt.forEach(t),ve=u(e),q=i(e,"P",{});var jt=r(q);ze=h(jt,`One thing to note is that the splitting method I have described above creates nodes that are allocated in a
depth-first manner. You can also allocate the nodes then traverse to get pairs of bounding volumes next to each
other in memory. This is assuming you are allocating memory from athe lower to a higher address, e. g. by
appending to a list.`),jt.forEach(t),we=u(e),C=i(e,"H1",{});var Tt=r(C);Ue=h(Tt,"Objects outside of the Acceleration Data Structure"),Tt.forEach(t),ge=u(e),L=i(e,"P",{});var Et=r(L);Re=h(Et,`We always have the method of linear iteration in our hands, so we can use this whenever an object we want to
intersect is not in the acceleration data structure. If we have moving characters in a scene for an FPS game,
for example, we can first render the scene, also store its depth buffer, then blit the character renders onto
the background according to the background and character depth buffers. If we really need to test ray
intersection on the backgrounds and the character, we treat the background BVH as a single object, intersect
both the character and the background, and report the closest hit result among these tests.`),Et.forEach(t),_e=u(e),_=i(e,"P",{});var Ne=r(_);qe=h(Ne,`Rigged meshes are very hard to generate acceleration data structures for. If the deformation happens before the
data is sent to the GPU, then the BVH can be generated each frame, including the character mesh triangles. This
seems like `),y=i(Ne,"A",{href:!0,rel:!0});var kt=r(y);Ce=h(kt,"how Epic Games\u2019 Unreal Engine Version 5 seems to work."),kt.forEach(t),Ne.forEach(t),this.h()},h(){It(A.src,Je=Ht)||N(A,"src",Je),N(A,"alt","Two-Level BVH Demonstration for Median Split"),It(F.src,Ke=Ot)||N(F,"src",Ke),N(F,"alt","Two-Level BVH Demonstration for Midpoint Split"),N(y,"href","https://docs.unrealengine.com/5.0/en-US/ray-tracing-performance-guide-in-unreal-engine/#toplevelaccelerationstructurebuild"),N(y,"rel","nofollow")},m(e,a){o(e,p,a),n(p,f),o(e,b,a),o(e,v,a),n(v,m),o(e,d,a),o(e,w,a),n(w,ye),o(e,K,a),o(e,T,a),n(T,je),o(e,X,a),o(e,E,a),n(E,Te),o(e,Z,a),o(e,k,a),n(k,Ee),o(e,ee,a),o(e,P,a),n(P,ke),o(e,te,a),o(e,S,a),n(S,Pe),o(e,ae,a),o(e,I,a),n(I,Se),o(e,oe,a),o(e,H,a),n(H,Ie),o(e,se,a),o(e,O,a),n(O,He),o(e,ie,a),o(e,B,a),n(B,Oe),o(e,ne,a),o(e,g,a),n(g,Be),n(g,Y),n(Y,Me),o(e,re,a),o(e,M,a),n(M,Q),n(Q,xe),o(e,le,a),o(e,x,a),n(x,Ve),o(e,he,a),o(e,V,a),n(V,A),o(e,ce,a),o(e,G,a),n(G,J),n(J,Ae),o(e,ue,a),o(e,D,a),n(D,Ge),o(e,pe,a),o(e,W,a),n(W,F),o(e,me,a),o(e,$,a),n($,De),o(e,de,a),o(e,z,a),n(z,We),o(e,fe,a),o(e,U,a),n(U,Fe),o(e,be,a),o(e,R,a),n(R,$e),o(e,ve,a),o(e,q,a),n(q,ze),o(e,we,a),o(e,C,a),n(C,Ue),o(e,ge,a),o(e,L,a),n(L,Re),o(e,_e,a),o(e,_,a),n(_,qe),n(_,y),n(y,Ce)},p:zt,d(e){e&&t(p),e&&t(b),e&&t(v),e&&t(d),e&&t(w),e&&t(K),e&&t(T),e&&t(X),e&&t(E),e&&t(Z),e&&t(k),e&&t(ee),e&&t(P),e&&t(te),e&&t(S),e&&t(ae),e&&t(I),e&&t(oe),e&&t(H),e&&t(se),e&&t(O),e&&t(ie),e&&t(B),e&&t(ne),e&&t(g),e&&t(re),e&&t(M),e&&t(le),e&&t(x),e&&t(he),e&&t(V),e&&t(ce),e&&t(G),e&&t(ue),e&&t(D),e&&t(pe),e&&t(W),e&&t(me),e&&t($),e&&t(de),e&&t(z),e&&t(fe),e&&t(U),e&&t(be),e&&t(R),e&&t(ve),e&&t(q),e&&t(we),e&&t(C),e&&t(ge),e&&t(L),e&&t(_e),e&&t(_)}}}function qt(j){let p,f;const b=[j[0],Qe];let v={$$slots:{default:[Rt]},$$scope:{ctx:j}};for(let m=0;m<b.length;m+=1)v=Ye(v,b[m]);return p=new Ut({props:v}),{c(){Vt(p.$$.fragment)},l(m){At(p.$$.fragment,m)},m(m,d){Gt(p,m,d),f=!0},p(m,[d]){const w=d&1?Dt(b,[d&1&&Pt(m[0]),d&0&&Pt(Qe)]):{};d&2&&(w.$$scope={dirty:d,ctx:m}),p.$set(w)},i(m){f||(Wt(p.$$.fragment,m),f=!0)},o(m){Ft(p.$$.fragment,m),f=!1},d(m){$t(p,m)}}}const Qe={title:"Acceleration Data Structures",excerpt:"How to get spatial information about the scene efficiently",author:{nickname:"boraini",name:"Mert Bora \u0130nevi",social:{linkedin:"https://linkedin.com/in/boraini",github:"https://github.com/boraini",deviantart:"https://deviantart.com/boraini",twitter:"https://twitter.com/BorainiOfficial",instagram:"https://instagram.com/borainevi",tumblr:"https://tumblr.com/boraini",scratch:"https://scratch.mit.edu/users/boraini",abmdevandgames:"https://abmdevandgames.blogspot.com"},page:"/blog/authors/boraini/"},thumbnail:"./_acceleration-data-structures/ads-thumbnail.svg",date:"2023-09-05"};function Ct(j,p,f){return j.$$set=b=>{f(0,p=Ye(Ye({},p),St(b)))},p=St(p),[p]}class Lt extends Bt{constructor(p){super(),Mt(this,p,Ct,qt,xt,{})}}const Kt=Object.freeze(Object.defineProperty({__proto__:null,default:Lt,metadata:Qe},Symbol.toStringTag,{value:"Module"}));export{Lt as A,Qt as _,Jt as a,Kt as b,Qe as m};
