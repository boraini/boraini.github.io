import{S as Rn,i as An,s as Gn,l as E,V as S,u as B,m as w,p,W as F,h as a,v as H,q as s,r as z,b as i,G as e,X as bn,w as ns,n as wn,Y as ss,o as as,H as es,D as xn,x as qn,y as Nn,z as Un,A as ts,B as Cn,f as Jn,t as Vn,C as Qn,Q as Xn,a as T,c as L}from"./index-8e6002e7.js";import{B as os}from"./_blog_layout-a73ee55d.js";function ps(t){let o,l,f,u,h,d,x,v,O,b,_,U,C,an,c,g,M,D,W,A,y,J,G,X,en,R,V,q,j,Y,K,I,tn,Z,P,on,$,rn,ln;return{c(){o=E("div"),l=document.createElementNS("w3.org/2000/svg","svg"),f=S("defs"),u=S("marker"),h=S("path"),d=S("marker"),x=S("path"),v=S("marker"),O=S("path"),b=S("g"),_=S("line"),g=S("line"),y=S("line"),R=S("text"),V=B(t[2]),q=S("g"),j=S("circle"),I=S("circle"),P=S("circle"),this.h()},l(k){o=w(k,"DIV",{class:!0});var m=p(o);l=w(m,"svg",{class:!0,xmlns:!0,viewBox:!0});var nn=p(l);f=F(nn,"defs",{});var Q=p(f);u=F(Q,"marker",{id:!0,viewBox:!0,refX:!0,refY:!0,markerWidth:!0,markerHeight:!0,orient:!0});var kn=p(u);h=F(kn,"path",{d:!0,style:!0}),p(h).forEach(a),kn.forEach(a),d=F(Q,"marker",{id:!0,viewBox:!0,refX:!0,refY:!0,markerWidth:!0,markerHeight:!0,orient:!0});var cn=p(d);x=F(cn,"path",{d:!0,style:!0}),p(x).forEach(a),cn.forEach(a),v=F(Q,"marker",{id:!0,viewBox:!0,refX:!0,refY:!0,markerWidth:!0,markerHeight:!0,orient:!0});var sn=p(v);O=F(sn,"path",{d:!0,style:!0}),p(O).forEach(a),sn.forEach(a),Q.forEach(a),b=F(nn,"g",{id:!0,style:!0});var pn=p(b);_=F(pn,"line",{x1:!0,y1:!0,x2:!0,y2:!0,style:!0}),p(_).forEach(a),g=F(pn,"line",{x1:!0,y1:!0,x2:!0,y2:!0,style:!0}),p(g).forEach(a),y=F(pn,"line",{x1:!0,y1:!0,x2:!0,y2:!0,style:!0}),p(y).forEach(a),pn.forEach(a),R=F(nn,"text",{x:!0,y:!0,"font-size":!0,style:!0});var un=p(R);V=H(un,t[2]),un.forEach(a),q=F(nn,"g",{id:!0,style:!0});var N=p(q);j=F(N,"circle",{id:!0,cx:!0,cy:!0,r:!0,fill:!0,stroke:!0,"stroke-width":!0}),p(j).forEach(a),I=F(N,"circle",{id:!0,cx:!0,cy:!0,r:!0,fill:!0,stroke:!0,"stroke-width":!0}),p(I).forEach(a),P=F(N,"circle",{id:!0,cx:!0,cy:!0,r:!0,fill:!0,stroke:!0,"stroke-width":!0}),p(P).forEach(a),N.forEach(a),nn.forEach(a),m.forEach(a),this.h()},h(){s(h,"d","M 0 0 L 10 5 L 0 10 z"),z(h,"fill","red"),s(u,"id","arrow1"),s(u,"viewBox","0 0 10 10"),s(u,"refX","5"),s(u,"refY","5"),s(u,"markerWidth","50"),s(u,"markerHeight","25"),s(u,"orient","auto-start-reverse"),s(x,"d","M 0 0 L 10 5 L 0 10 z"),z(x,"fill","var(--page-foreground)"),s(d,"id","arrow2"),s(d,"viewBox","0 0 10 10"),s(d,"refX","5"),s(d,"refY","5"),s(d,"markerWidth","50"),s(d,"markerHeight","25"),s(d,"orient","auto-start-reverse"),s(O,"d","M 0 0 L 10 5 L 0 10 z"),z(O,"fill","aqua"),s(v,"id","arrow3"),s(v,"viewBox","0 0 10 10"),s(v,"refX","5"),s(v,"refY","5"),s(v,"markerWidth","50"),s(v,"markerHeight","25"),s(v,"orient","auto-start-reverse"),s(_,"x1",U=t[0][0][0]),s(_,"y1",C=t[0][0][1]),s(_,"x2",an=t[0][1][0]),s(_,"y2",c=t[0][1][1]),z(_,"--stroke-color","red"),z(_,"stroke","var(--stroke-color)"),z(_,"marker-end","url(#arrow1)"),z(_,"stroke-width","0.1"),s(g,"x1",M=t[0][1][0]),s(g,"y1",D=t[0][1][1]),s(g,"x2",W=t[0][2][0]),s(g,"y2",A=t[0][2][1]),z(g,"--stroke-color","var(--page-foreground)"),z(g,"stroke","var(--stroke-color)"),z(g,"marker-end","url(#arrow2)"),z(g,"stroke-width","0.1"),s(y,"x1",J=t[0][2][0]),s(y,"y1",G=t[0][2][1]),s(y,"x2",X=t[0][0][0]),s(y,"y2",en=t[0][0][1]),z(y,"--stroke-color","aqua"),z(y,"stroke","var(--stroke-color)"),z(y,"marker-start","url(#arrow3)"),z(y,"stroke-width","0.1"),s(b,"id","trianglelayer"),z(b,"transform","scaleY(-1)"),s(R,"x","-10"),s(R,"y","10"),s(R,"font-size","1.6"),z(R,"fill","var(--page-foreground)"),s(j,"id","pointer-1"),s(j,"cx",Y=t[0][0][0]),s(j,"cy",K=t[0][0][1]),s(j,"r","0.8"),s(j,"fill","#f00"),s(j,"stroke","#000"),s(j,"stroke-width","0.1"),s(I,"id","pointer-2"),s(I,"cx",tn=t[0][1][0]),s(I,"cy",Z=t[0][1][1]),s(I,"r","0.8"),s(I,"fill","#f00"),s(I,"stroke","#000"),s(I,"stroke-width","0.1"),s(P,"id","pointer-3"),s(P,"cx",on=t[0][2][0]),s(P,"cy",$=t[0][2][1]),s(P,"r","0.8"),s(P,"fill","#f00"),s(P,"stroke","#000"),s(P,"stroke-width","0.1"),s(q,"id","pointerlayer"),z(q,"transform","scaleY(-1)"),s(l,"class","compass-menu svelte-s9mvsj"),s(l,"xmlns","w3.org/2000/svg"),s(l,"viewBox","-12 -12 24 24"),s(o,"class","applet")},m(k,m){i(k,o,m),e(o,l),e(l,f),e(f,u),e(u,h),e(f,d),e(d,x),e(f,v),e(v,O),e(l,b),e(b,_),e(b,g),e(b,y),e(l,R),e(R,V),e(l,q),e(q,j),e(q,I),e(q,P),t[6](l),rn||(ln=[bn(l,"pointerdown",t[3]),bn(l,"pointerup",t[5]),bn(l,"pointermove",t[4]),bn(l,"scroll",rs)],rn=!0)},p(k,[m]){m&1&&U!==(U=k[0][0][0])&&s(_,"x1",U),m&1&&C!==(C=k[0][0][1])&&s(_,"y1",C),m&1&&an!==(an=k[0][1][0])&&s(_,"x2",an),m&1&&c!==(c=k[0][1][1])&&s(_,"y2",c),m&1&&M!==(M=k[0][1][0])&&s(g,"x1",M),m&1&&D!==(D=k[0][1][1])&&s(g,"y1",D),m&1&&W!==(W=k[0][2][0])&&s(g,"x2",W),m&1&&A!==(A=k[0][2][1])&&s(g,"y2",A),m&1&&J!==(J=k[0][2][0])&&s(y,"x1",J),m&1&&G!==(G=k[0][2][1])&&s(y,"y1",G),m&1&&X!==(X=k[0][0][0])&&s(y,"x2",X),m&1&&en!==(en=k[0][0][1])&&s(y,"y2",en),m&4&&ns(V,k[2]),m&1&&Y!==(Y=k[0][0][0])&&s(j,"cx",Y),m&1&&K!==(K=k[0][0][1])&&s(j,"cy",K),m&1&&tn!==(tn=k[0][1][0])&&s(I,"cx",tn),m&1&&Z!==(Z=k[0][1][1])&&s(I,"cy",Z),m&1&&on!==(on=k[0][2][0])&&s(P,"cx",on),m&1&&$!==($=k[0][2][1])&&s(P,"cy",$)},i:wn,o:wn,d(k){k&&a(o),t[6](null),rn=!1,ss(ln)}}}const rs=t=>t.preventDefault();function ls(t,o,l){let{corners:f=[[-5,-5],[-4,8],[5,-3]]}=o,{compassField:u}=o,{message:h="Try dragging the red dots."}=o;var d={x:-12,y:-12,width:24,height:24};function x(){u||l(1,u=window.COMPASS_FIELD),v=u.getBoundingClientRect()}var v;function O(c,g){var M=(c-v.left)/v.width*d.width+d.x;M>10?M=10:M<-10&&(M=-10);var D=-(g-v.top)/v.height*d.height-d.y;D>10?D=10:D<-10&&(D=-10);let W=1/0,A;for(let G of f){const X=Math.hypot(G[0]-M,G[1]-D);X<W&&(W=X,A=G)}A[0]=M,A[1]=D,l(0,f);const y=[f[1][0]-f[0][0],f[1][1]-f[0][1]],J=[f[2][0]-f[0][0],f[2][1]-f[0][1]];l(2,h=`Triangle is facing ${J[0]*y[1]-J[1]*y[0]>0?"front":"back"}.`)}var b=void 0;function _(c){c.preventDefault(),b||(b=c.pointerId,console.log(b),O(c.clientX,c.clientY))}function U(c){c.preventDefault(),c.pointerId==b&&O(c.clientX,c.clientY)}function C(c){c.preventDefault(),c.pointerId==b&&(b=void 0)}as(()=>{window.COMPASS_FIELD=u,addEventListener("resize",x,{passive:!0}),addEventListener("scroll",x,{passive:!0}),x()});function an(c){es[c?"unshift":"push"](()=>{u=c,l(1,u)})}return t.$$set=c=>{"corners"in c&&l(0,f=c.corners),"compassField"in c&&l(1,u=c.compassField),"message"in c&&l(2,h=c.message)},[f,u,h,_,U,C,an]}class cs extends Rn{constructor(o){super(),An(this,o,ls,ps,Gn,{corners:0,compassField:1,message:2})}}function is(t){let o,l,f,u,h,d,x,v,O,b,_,U,C,an=`<code class="language-glsl"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">extension</span> <span class="token expression">GL_OES_standard_derivatives <span class="token operator">:</span> enable</span></span>

<span class="token keyword">precision</span> <span class="token keyword">highp</span> <span class="token keyword">float</span><span class="token punctuation">;</span>

<span class="token comment">//GLSL Sandbox Uniform</span>
<span class="token keyword">uniform</span> <span class="token keyword">vec2</span> resolution<span class="token punctuation">;</span>

<span class="token comment">//Clockwise order has to be a, b, c. a, b, c have already been projected.</span>
<span class="token keyword">bool</span> <span class="token function">isFront</span><span class="token punctuation">(</span><span class="token keyword">vec4</span> a<span class="token punctuation">,</span> <span class="token keyword">vec4</span> b<span class="token punctuation">,</span> <span class="token keyword">vec4</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">vec3</span> atob <span class="token operator">=</span> <span class="token punctuation">(</span>b <span class="token operator">-</span> a<span class="token punctuation">)</span><span class="token punctuation">.</span>xyz<span class="token punctuation">;</span>
	<span class="token keyword">vec3</span> atoc <span class="token operator">=</span> <span class="token punctuation">(</span>c <span class="token operator">-</span> a<span class="token punctuation">)</span><span class="token punctuation">.</span>xyz<span class="token punctuation">;</span>
	atob<span class="token punctuation">.</span>z <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
	atoc<span class="token punctuation">.</span>z <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>

	<span class="token keyword">return</span> <span class="token function">cross</span><span class="token punctuation">(</span>atoc<span class="token punctuation">,</span> atob<span class="token punctuation">)</span><span class="token punctuation">.</span>z <span class="token operator">></span> <span class="token number">0.0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">vec4</span> position <span class="token operator">=</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
	position<span class="token punctuation">.</span>xy <span class="token operator">=</span> gl_FragCoord<span class="token punctuation">.</span>xy <span class="token operator">/</span> resolution<span class="token punctuation">.</span>xy<span class="token punctuation">;</span>

	<span class="token comment">//if the triangle formed by (0, 0), (1, 1), and the screen point faces front</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isFront</span><span class="token punctuation">(</span><span class="token keyword">vec4</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> position<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		gl_FragColor <span class="token operator">=</span>  <span class="token keyword">vec4</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		gl_FragColor <span class="token operator">=</span>  <span class="token keyword">vec4</span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code>`,c,g,M,D,W,A,y,J,G,X,en,R,V,q,j,Y,K,I,tn,Z,P,on,$,rn,ln,k,m,nn,Q,kn,cn,sn,pn,un,N,Kn=`<code class="language-js"><span class="token keyword">let</span> triangles <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token punctuation">[</span><span class="token punctuation">&#123;</span><span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token literal-property property">z</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">z</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token literal-property property">z</span><span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token punctuation">&#123;</span><span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token literal-property property">z</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">z</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token literal-property property">z</span><span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token punctuation">&#123;</span><span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token literal-property property">z</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">z</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token literal-property property">z</span><span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token comment">//...</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">project</span><span class="token punctuation">(</span><span class="token parameter">p</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">//project onto the z-plane</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span>p<span class="token punctuation">.</span>x<span class="token punctuation">,</span> p<span class="token punctuation">.</span>y<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">function</span> <span class="token function">triangleComparer</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>z <span class="token operator">+</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>z <span class="token operator">+</span> a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>z<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span>b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>z <span class="token operator">+</span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>z <span class="token operator">+</span> b<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">//remove back-facing triangles</span>
triangles <span class="token operator">=</span> triangles<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token parameter">tri</span> <span class="token operator">=></span> <span class="token function">isFront</span><span class="token punctuation">(</span><span class="token function">project</span><span class="token punctuation">(</span>tri<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">project</span><span class="token punctuation">(</span>tri<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">project</span><span class="token punctuation">(</span>tri<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//sort based on centroid z</span>
triangles<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>triangleComparer<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//rasterize needs to be implemented</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token literal-property property">triangle</span> <span class="token operator">:</span> triangles<span class="token punctuation">)</span> <span class="token function">rasterize</span><span class="token punctuation">(</span>triangle<span class="token punctuation">)</span><span class="token punctuation">;</span></code>`,mn,fn,vn,yn,hn,_n,gn;return W=new cs({}),{c(){o=E("p"),l=B(`Hidden surface removal is one of the most fundamental problems to solve before rendering almost any 3D scene.
Not only that you get better performance by rendering less objects, you can also end up with a non-intersecting
set of polygons to simply render.`),f=T(),u=E("h2"),h=B("Hiding Based on Turning Direction of Projected Triangles"),d=T(),x=E("p"),v=B(`3D objects in contemporary applications are usually composed of 3D triangles whose edges are coinciding with
each other to produce a closed form. In simple triangle-rasterising rendering, these triangles are first
projected onto the camera frustum\u2019s near plane using perspective or orthographic projection. When this is done,
the vertices either appear in clockwise or anticlockwise order. Usually if the triangle appears clockwise, we
say we are seeing the front side of it and render.`),O=T(),b=E("p"),_=B("Which side we are on can easily be figured out by taking the cross product of two edges."),U=T(),C=E("pre"),c=T(),g=E("p"),M=B("In the following applet, the blue vector is atoc and the red vector is atob. You can follow the direction of the right arrow to determine if the triangle is clockwise or anticlockwise."),D=T(),qn(W.$$.fragment),A=T(),y=E("h2"),J=B("Managing Overlapping Parts"),G=T(),X=E("p"),en=B("This works great to correctly hide the necessary faces of convex shapes like spheres or cubes, but struggles for shapes which have complex shapes whose parts may overlap each other when projected at certain orientations."),R=T(),V=E("p"),q=B("For each overlapping part of the image, we find which object is closest to the camera. This can be done by"),j=T(),Y=E("ul"),K=E("li"),I=B("ray tracing"),tn=T(),Z=E("li"),P=B("painter\u2019s algorithm"),on=T(),$=E("li"),rn=B("z-buffering"),ln=T(),k=E("p"),m=B(`In ray tracing, a ray is generated from the camera that contains all 3D points that would be projected to the solved pixel. Then this ray is
traced in miniscule steps and the pixel color is determined according to which object is hit first. The ray may be reflected, branched etc.
to simulate light even more realistically, which would bring us to physics-based rendering.`),nn=T(),Q=E("p"),kn=B(`But what if we want to be fast? We can be fast by handling each triangle instead of each pixel on the screen. The first way is to sort triangles
based on the distance of their centroids to the camera, then rendering them from farthest to closest. This is called painter\u2019s algorithm, referring
to painters painting their paintings starting from the sky, then the background objects, and finally the closest subjects.`),cn=T(),sn=E("p"),pn=B("This is usually not done in OpenGL, so I am providing JS code which does the thing."),un=T(),N=E("pre"),mn=T(),fn=E("p"),vn=B("The other way is to rasterising triangles the order they appear, but also onto a depth buffer of the render. After efficiently finding the depth value of each pixel of the triangle, we compose each pixel onto the final image if the depth of the pixel is closer to the camera than anything before."),yn=T(),hn=E("p"),_n=B("OpenGL pretty much does the depth-buffering for us, so no example code will be given here. It can be fraud at best."),this.h()},l(n){o=w(n,"P",{});var r=p(o);l=H(r,`Hidden surface removal is one of the most fundamental problems to solve before rendering almost any 3D scene.
Not only that you get better performance by rendering less objects, you can also end up with a non-intersecting
set of polygons to simply render.`),r.forEach(a),f=L(n),u=w(n,"H2",{});var jn=p(u);h=H(jn,"Hiding Based on Turning Direction of Projected Triangles"),jn.forEach(a),d=L(n),x=w(n,"P",{});var zn=p(x);v=H(zn,`3D objects in contemporary applications are usually composed of 3D triangles whose edges are coinciding with
each other to produce a closed form. In simple triangle-rasterising rendering, these triangles are first
projected onto the camera frustum\u2019s near plane using perspective or orthographic projection. When this is done,
the vertices either appear in clockwise or anticlockwise order. Usually if the triangle appears clockwise, we
say we are seeing the front side of it and render.`),zn.forEach(a),O=L(n),b=w(n,"P",{});var Tn=p(b);_=H(Tn,"Which side we are on can easily be figured out by taking the cross product of two edges."),Tn.forEach(a),U=L(n),C=w(n,"PRE",{class:!0});var Zn=p(C);Zn.forEach(a),c=L(n),g=w(n,"P",{});var Ln=p(g);M=H(Ln,"In the following applet, the blue vector is atoc and the red vector is atob. You can follow the direction of the right arrow to determine if the triangle is clockwise or anticlockwise."),Ln.forEach(a),D=L(n),Nn(W.$$.fragment,n),A=L(n),y=w(n,"H2",{});var In=p(y);J=H(In,"Managing Overlapping Parts"),In.forEach(a),G=L(n),X=w(n,"P",{});var Pn=p(X);en=H(Pn,"This works great to correctly hide the necessary faces of convex shapes like spheres or cubes, but struggles for shapes which have complex shapes whose parts may overlap each other when projected at certain orientations."),Pn.forEach(a),R=L(n),V=w(n,"P",{});var Bn=p(V);q=H(Bn,"For each overlapping part of the image, we find which object is closest to the camera. This can be done by"),Bn.forEach(a),j=L(n),Y=w(n,"UL",{});var dn=p(Y);K=w(dn,"LI",{});var Hn=p(K);I=H(Hn,"ray tracing"),Hn.forEach(a),tn=L(dn),Z=w(dn,"LI",{});var Dn=p(Z);P=H(Dn,"painter\u2019s algorithm"),Dn.forEach(a),on=L(dn),$=w(dn,"LI",{});var Sn=p($);rn=H(Sn,"z-buffering"),Sn.forEach(a),dn.forEach(a),ln=L(n),k=w(n,"P",{});var Fn=p(k);m=H(Fn,`In ray tracing, a ray is generated from the camera that contains all 3D points that would be projected to the solved pixel. Then this ray is
traced in miniscule steps and the pixel color is determined according to which object is hit first. The ray may be reflected, branched etc.
to simulate light even more realistically, which would bring us to physics-based rendering.`),Fn.forEach(a),nn=L(n),Q=w(n,"P",{});var Mn=p(Q);kn=H(Mn,`But what if we want to be fast? We can be fast by handling each triangle instead of each pixel on the screen. The first way is to sort triangles
based on the distance of their centroids to the camera, then rendering them from farthest to closest. This is called painter\u2019s algorithm, referring
to painters painting their paintings starting from the sky, then the background objects, and finally the closest subjects.`),Mn.forEach(a),cn=L(n),sn=w(n,"P",{});var Wn=p(sn);pn=H(Wn,"This is usually not done in OpenGL, so I am providing JS code which does the thing."),Wn.forEach(a),un=L(n),N=w(n,"PRE",{class:!0});var $n=p(N);$n.forEach(a),mn=L(n),fn=w(n,"P",{});var Yn=p(fn);vn=H(Yn,"The other way is to rasterising triangles the order they appear, but also onto a depth buffer of the render. After efficiently finding the depth value of each pixel of the triangle, we compose each pixel onto the final image if the depth of the pixel is closer to the camera than anything before."),Yn.forEach(a),yn=L(n),hn=w(n,"P",{});var On=p(hn);_n=H(On,"OpenGL pretty much does the depth-buffering for us, so no example code will be given here. It can be fraud at best."),On.forEach(a),this.h()},h(){s(C,"class","language-glsl"),s(N,"class","language-js")},m(n,r){i(n,o,r),e(o,l),i(n,f,r),i(n,u,r),e(u,h),i(n,d,r),i(n,x,r),e(x,v),i(n,O,r),i(n,b,r),e(b,_),i(n,U,r),i(n,C,r),C.innerHTML=an,i(n,c,r),i(n,g,r),e(g,M),i(n,D,r),Un(W,n,r),i(n,A,r),i(n,y,r),e(y,J),i(n,G,r),i(n,X,r),e(X,en),i(n,R,r),i(n,V,r),e(V,q),i(n,j,r),i(n,Y,r),e(Y,K),e(K,I),e(Y,tn),e(Y,Z),e(Z,P),e(Y,on),e(Y,$),e($,rn),i(n,ln,r),i(n,k,r),e(k,m),i(n,nn,r),i(n,Q,r),e(Q,kn),i(n,cn,r),i(n,sn,r),e(sn,pn),i(n,un,r),i(n,N,r),N.innerHTML=Kn,i(n,mn,r),i(n,fn,r),e(fn,vn),i(n,yn,r),i(n,hn,r),e(hn,_n),gn=!0},p:wn,i(n){gn||(Jn(W.$$.fragment,n),gn=!0)},o(n){Vn(W.$$.fragment,n),gn=!1},d(n){n&&a(o),n&&a(f),n&&a(u),n&&a(d),n&&a(x),n&&a(O),n&&a(b),n&&a(U),n&&a(C),n&&a(c),n&&a(g),n&&a(D),Qn(W,n),n&&a(A),n&&a(y),n&&a(G),n&&a(X),n&&a(R),n&&a(V),n&&a(j),n&&a(Y),n&&a(ln),n&&a(k),n&&a(nn),n&&a(Q),n&&a(cn),n&&a(sn),n&&a(un),n&&a(N),n&&a(mn),n&&a(fn),n&&a(yn),n&&a(hn)}}}function us(t){let o,l;const f=[t[0],En];let u={$$slots:{default:[is]},$$scope:{ctx:t}};for(let h=0;h<f.length;h+=1)u=xn(u,f[h]);return o=new os({props:u}),{c(){qn(o.$$.fragment)},l(h){Nn(o.$$.fragment,h)},m(h,d){Un(o,h,d),l=!0},p(h,[d]){const x=d&1?ts(f,[d&1&&Cn(h[0]),d&0&&Cn(En)]):{};d&2&&(x.$$scope={dirty:d,ctx:h}),o.$set(x)},i(h){l||(Jn(o.$$.fragment,h),l=!0)},o(h){Vn(o.$$.fragment,h),l=!1},d(h){Qn(o,h)}}}const En={title:"Hidden Surface Removal",excerpt:"Introduction to methods of hidden surface removal in contemporary 3D computer graphics",author:{nickname:"boraini",name:"Mert Bora \u0130nevi",social:{linkedin:"https://linkedin.com/in/boraini",github:"https://github.com/boraini",deviantart:"https://deviantart.com/boraini",twitter:"https://twitter.com/BorainiOfficial",instagram:"https://instagram.com/borainevi",tumblr:"https://tumblr.com/boraini",scratch:"https://scratch.mit.edu/users/boraini",abmdevandgames:"https://abmdevandgames.blogspot.com"},page:"/blog/authors/boraini/"},thumbnail:"./triangle.png",date:"2022-07-30",tags:["3d-graphics"]};function ks(t,o,l){return t.$$set=f=>{l(0,o=xn(xn({},o),Xn(f)))},o=Xn(o),[o]}class fs extends Rn{constructor(o){super(),An(this,o,ks,us,Gn,{})}}const ms=Object.freeze(Object.defineProperty({__proto__:null,default:fs,metadata:En},Symbol.toStringTag,{value:"Module"}));export{fs as H,ms as _,En as m};
